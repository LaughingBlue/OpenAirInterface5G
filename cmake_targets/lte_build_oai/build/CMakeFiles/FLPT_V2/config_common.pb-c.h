/* Generated by the protocol buffer compiler.  DO NOT EDIT! */
/* Generated from: config_common.proto */

#ifndef PROTOBUF_C_config_5fcommon_2eproto__INCLUDED
#define PROTOBUF_C_config_5fcommon_2eproto__INCLUDED

#include <protobuf-c/protobuf-c.h>

PROTOBUF_C__BEGIN_DECLS

#if PROTOBUF_C_VERSION_NUMBER < 1000000
# error This file was generated by a newer version of protoc-c which is incompatible with your libprotobuf-c headers. Please update your headers.
#elif 1002001 < PROTOBUF_C_MIN_COMPILER_VERSION
# error This file was generated by an older version of protoc-c which is incompatible with your libprotobuf-c headers. Please regenerate this file with a newer version of protoc-c.
#endif


typedef struct _Protocol__FlexSiConfig Protocol__FlexSiConfig;
typedef struct _Protocol__FlexSiMessage Protocol__FlexSiMessage;
typedef struct _Protocol__FlexDlSlice Protocol__FlexDlSlice;
typedef struct _Protocol__FlexUlSlice Protocol__FlexUlSlice;
typedef struct _Protocol__FlexDrxConfig Protocol__FlexDrxConfig;
typedef struct _Protocol__FlexSpsConfig Protocol__FlexSpsConfig;
typedef struct _Protocol__FlexSrConfig Protocol__FlexSrConfig;
typedef struct _Protocol__FlexCqiConfig Protocol__FlexCqiConfig;
typedef struct _Protocol__FlexUeCapabilities Protocol__FlexUeCapabilities;
typedef struct _Protocol__FlexScellConfig Protocol__FlexScellConfig;
typedef struct _Protocol__FlexLcConfig Protocol__FlexLcConfig;
typedef struct _Protocol__FlexPlmn Protocol__FlexPlmn;


/* --- enums --- */

typedef enum _Protocol__FlexHoppingMode {
  PROTOCOL__FLEX_HOPPING_MODE__FLHM_INTER = 0,
  PROTOCOL__FLEX_HOPPING_MODE__FLHM_INTERINTRA = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTOCOL__FLEX_HOPPING_MODE)
} Protocol__FlexHoppingMode;
typedef enum _Protocol__FlexPhichResource {
  PROTOCOL__FLEX_PHICH_RESOURCE__FLPR_ONE_SIXTH = 0,
  PROTOCOL__FLEX_PHICH_RESOURCE__FLPR_HALF = 1,
  PROTOCOL__FLEX_PHICH_RESOURCE__FLPR_ONE = 2,
  PROTOCOL__FLEX_PHICH_RESOURCE__FLPR_TWO = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTOCOL__FLEX_PHICH_RESOURCE)
} Protocol__FlexPhichResource;
typedef enum _Protocol__FlexPhichDuration {
  PROTOCOL__FLEX_PHICH_DURATION__FLPD_NORMAL = 0,
  PROTOCOL__FLEX_PHICH_DURATION__FLPD_EXTENDED = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTOCOL__FLEX_PHICH_DURATION)
} Protocol__FlexPhichDuration;
typedef enum _Protocol__FlexUlCyclicPrefixLength {
  PROTOCOL__FLEX_UL_CYCLIC_PREFIX_LENGTH__FLUCPL_NORMAL = 0,
  PROTOCOL__FLEX_UL_CYCLIC_PREFIX_LENGTH__FLUCPL_EXTENDED = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTOCOL__FLEX_UL_CYCLIC_PREFIX_LENGTH)
} Protocol__FlexUlCyclicPrefixLength;
typedef enum _Protocol__FlexDlCyclicPrefixLength {
  PROTOCOL__FLEX_DL_CYCLIC_PREFIX_LENGTH__FLDCPL_NORMAL = 0,
  PROTOCOL__FLEX_DL_CYCLIC_PREFIX_LENGTH__FLDCPL_EXTENDED = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTOCOL__FLEX_DL_CYCLIC_PREFIX_LENGTH)
} Protocol__FlexDlCyclicPrefixLength;
typedef enum _Protocol__FlexDuplexMode {
  PROTOCOL__FLEX_DUPLEX_MODE__FLDM_TDD = 0,
  PROTOCOL__FLEX_DUPLEX_MODE__FLDM_FDD = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTOCOL__FLEX_DUPLEX_MODE)
} Protocol__FlexDuplexMode;
typedef enum _Protocol__FlexQam {
  PROTOCOL__FLEX_QAM__FLEQ_MOD_16QAM = 0,
  PROTOCOL__FLEX_QAM__FLEQ_MOD_64QAM = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTOCOL__FLEX_QAM)
} Protocol__FlexQam;
/*
 * Slice config related structures and enums
 */
typedef enum _Protocol__FlexDlSorting {
  /*
   * Highest HARQ first
   */
  PROTOCOL__FLEX_DL_SORTING__CR_ROUND = 0,
  /*
   * Highest SRB1+2 first
   */
  PROTOCOL__FLEX_DL_SORTING__CR_SRB12 = 1,
  /*
   * Highest HOL first
   */
  PROTOCOL__FLEX_DL_SORTING__CR_HOL = 2,
  /*
   * Greatest RLC buffer first
   */
  PROTOCOL__FLEX_DL_SORTING__CR_LC = 3,
  /*
   * Highest CQI first
   */
  PROTOCOL__FLEX_DL_SORTING__CR_CQI = 4,
  /*
   * Highest LC priority first
   */
  PROTOCOL__FLEX_DL_SORTING__CR_LCP = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTOCOL__FLEX_DL_SORTING)
} Protocol__FlexDlSorting;
typedef enum _Protocol__FlexUlSorting {
  /*
   * Highest HARQ first
   */
  PROTOCOL__FLEX_UL_SORTING__CRU_ROUND = 0,
  /*
   * Highest BSR first
   */
  PROTOCOL__FLEX_UL_SORTING__CRU_BUF = 1,
  /*
   * More bytes to schedule first
   */
  PROTOCOL__FLEX_UL_SORTING__CRU_BTS = 2,
  /*
   * Highest MCS first
   */
  PROTOCOL__FLEX_UL_SORTING__CRU_MCS = 3,
  /*
   * Highest LC priority first
   */
  PROTOCOL__FLEX_UL_SORTING__CRU_LCP = 4,
  /*
   * Highest HOL first
   */
  PROTOCOL__FLEX_UL_SORTING__CRU_HOL = 5
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTOCOL__FLEX_UL_SORTING)
} Protocol__FlexUlSorting;
typedef enum _Protocol__FlexDlAccountingPolicy {
  PROTOCOL__FLEX_DL_ACCOUNTING_POLICY__POL_FAIR = 0,
  PROTOCOL__FLEX_DL_ACCOUNTING_POLICY__POL_GREEDY = 1,
  PROTOCOL__FLEX_DL_ACCOUNTING_POLICY__POL_NUM = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTOCOL__FLEX_DL_ACCOUNTING_POLICY)
} Protocol__FlexDlAccountingPolicy;
typedef enum _Protocol__FlexUlAccountingPolicy {
  PROTOCOL__FLEX_UL_ACCOUNTING_POLICY__POLU_FAIR = 0,
  PROTOCOL__FLEX_UL_ACCOUNTING_POLICY__POLU_GREEDY = 1,
  PROTOCOL__FLEX_UL_ACCOUNTING_POLICY__POLU_NUM = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTOCOL__FLEX_UL_ACCOUNTING_POLICY)
} Protocol__FlexUlAccountingPolicy;
typedef enum _Protocol__FlexSliceLabel {
  PROTOCOL__FLEX_SLICE_LABEL__xMBB = 0,
  PROTOCOL__FLEX_SLICE_LABEL__URLLC = 1,
  PROTOCOL__FLEX_SLICE_LABEL__mMTC = 2,
  PROTOCOL__FLEX_SLICE_LABEL__xMTC = 3,
  PROTOCOL__FLEX_SLICE_LABEL__Other = 4
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTOCOL__FLEX_SLICE_LABEL)
} Protocol__FlexSliceLabel;
typedef enum _Protocol__FlexMeasGapConfigPattern {
  PROTOCOL__FLEX_MEAS_GAP_CONFIG_PATTERN__FLMGCP_GP1 = 0,
  PROTOCOL__FLEX_MEAS_GAP_CONFIG_PATTERN__FLMGCP_GP2 = 1,
  PROTOCOL__FLEX_MEAS_GAP_CONFIG_PATTERN__FLMGCP_OFF = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTOCOL__FLEX_MEAS_GAP_CONFIG_PATTERN)
} Protocol__FlexMeasGapConfigPattern;
typedef enum _Protocol__FlexSetupReleaseAction {
  PROTOCOL__FLEX_SETUP_RELEASE_ACTION__FLSRA_SETUP = 0,
  PROTOCOL__FLEX_SETUP_RELEASE_ACTION__FLSRA_RELEASE = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTOCOL__FLEX_SETUP_RELEASE_ACTION)
} Protocol__FlexSetupReleaseAction;
typedef enum _Protocol__FlexUeTransmissionAntenna {
  PROTOCOL__FLEX_UE_TRANSMISSION_ANTENNA__FLUTA_NONE = 0,
  PROTOCOL__FLEX_UE_TRANSMISSION_ANTENNA__FLUTA_OPEN_LOOP = 1,
  PROTOCOL__FLEX_UE_TRANSMISSION_ANTENNA__FLUTA_CLOSED_LOOP = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTOCOL__FLEX_UE_TRANSMISSION_ANTENNA)
} Protocol__FlexUeTransmissionAntenna;
typedef enum _Protocol__FlexAperiodicCqiReportMode {
  PROTOCOL__FLEX_APERIODIC_CQI_REPORT_MODE__FLACRM_RM12 = 0,
  PROTOCOL__FLEX_APERIODIC_CQI_REPORT_MODE__FLACRM_RM20 = 1,
  PROTOCOL__FLEX_APERIODIC_CQI_REPORT_MODE__FLACRM_RM22 = 2,
  PROTOCOL__FLEX_APERIODIC_CQI_REPORT_MODE__FLACRM_RM30 = 3,
  PROTOCOL__FLEX_APERIODIC_CQI_REPORT_MODE__FLACRM_RM31 = 4,
  PROTOCOL__FLEX_APERIODIC_CQI_REPORT_MODE__FLACRM_NONE = 5,
  PROTOCOL__FLEX_APERIODIC_CQI_REPORT_MODE__FLACRM_RM32_v1250 = 6,
  PROTOCOL__FLEX_APERIODIC_CQI_REPORT_MODE__FLACRM_RM10_v1310 = 7,
  PROTOCOL__FLEX_APERIODIC_CQI_REPORT_MODE__FLACRM_RM11_v1310 = 8
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTOCOL__FLEX_APERIODIC_CQI_REPORT_MODE)
} Protocol__FlexAperiodicCqiReportMode;
typedef enum _Protocol__FlexTddAckNackFeedbackMode {
  PROTOCOL__FLEX_TDD_ACK_NACK_FEEDBACK_MODE__FLTANFM_BUNDLING = 0,
  PROTOCOL__FLEX_TDD_ACK_NACK_FEEDBACK_MODE__FLTANFM_MULTIPLEXING = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTOCOL__FLEX_TDD_ACK_NACK_FEEDBACK_MODE)
} Protocol__FlexTddAckNackFeedbackMode;
typedef enum _Protocol__FlexLcDirection {
  PROTOCOL__FLEX_LC_DIRECTION__FLLCD_UL = 0,
  PROTOCOL__FLEX_LC_DIRECTION__FLLCD_DL = 1,
  PROTOCOL__FLEX_LC_DIRECTION__FLLCD_BOTH = 2
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTOCOL__FLEX_LC_DIRECTION)
} Protocol__FlexLcDirection;
typedef enum _Protocol__FlexQosBearerType {
  PROTOCOL__FLEX_QOS_BEARER_TYPE__FLQBT_NON_GBR = 0,
  PROTOCOL__FLEX_QOS_BEARER_TYPE__FLQBT_GBR = 1
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTOCOL__FLEX_QOS_BEARER_TYPE)
} Protocol__FlexQosBearerType;
typedef enum _Protocol__FlexUeStateChangeType {
  PROTOCOL__FLEX_UE_STATE_CHANGE_TYPE__FLUESC_UPDATED = 0,
  PROTOCOL__FLEX_UE_STATE_CHANGE_TYPE__FLUESC_ACTIVATED = 1,
  PROTOCOL__FLEX_UE_STATE_CHANGE_TYPE__FLUESC_DEACTIVATED = 2,
  PROTOCOL__FLEX_UE_STATE_CHANGE_TYPE__FLUESC_MOVED = 3
    PROTOBUF_C__FORCE_ENUM_TO_BE_INT_SIZE(PROTOCOL__FLEX_UE_STATE_CHANGE_TYPE)
} Protocol__FlexUeStateChangeType;

/* --- messages --- */

struct  _Protocol__FlexSiConfig
{
  ProtobufCMessage base;
  protobuf_c_boolean has_sfn;
  uint32_t sfn;
  /*
   * The length of SIB1 in bytes
   */
  protobuf_c_boolean has_sib1_length;
  uint32_t sib1_length;
  /*
   * The scheduling window for all SIs in SF
   */
  protobuf_c_boolean has_si_window_length;
  uint32_t si_window_length;
  /*
   * List of SI messages to be sent.
   */
  size_t n_si_message;
  Protocol__FlexSiMessage **si_message;
};
#define PROTOCOL__FLEX_SI_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&protocol__flex_si_config__descriptor) \
    , 0, 0, 0, 0, 0, 0, 0,NULL }


struct  _Protocol__FlexSiMessage
{
  ProtobufCMessage base;
  /*
   * Periodicity of SI msg in radio frames
   */
  protobuf_c_boolean has_periodicity;
  uint32_t periodicity;
  /*
   * The length of the SI message in bytes
   */
  protobuf_c_boolean has_length;
  uint32_t length;
};
#define PROTOCOL__FLEX_SI_MESSAGE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&protocol__flex_si_message__descriptor) \
    , 0, 0, 0, 0 }


struct  _Protocol__FlexDlSlice
{
  ProtobufCMessage base;
  protobuf_c_boolean has_id;
  uint32_t id;
  protobuf_c_boolean has_label;
  Protocol__FlexSliceLabel label;
  /*
   * should be between 0 and 100
   */
  protobuf_c_boolean has_percentage;
  uint32_t percentage;
  /*
   * whether this slice should be exempted form interslice sharing
   */
  protobuf_c_boolean has_isolation;
  protobuf_c_boolean isolation;
  /*
   * increasing value means increasing prio
   */
  protobuf_c_boolean has_priority;
  uint32_t priority;
  /*
   * min and max RB to use (in frequency) in the range [0, N_RBG_MAX]
   */
  protobuf_c_boolean has_position_low;
  uint32_t position_low;
  protobuf_c_boolean has_position_high;
  uint32_t position_high;
  /*
   * maximum MCS to be allowed in this slice
   */
  protobuf_c_boolean has_maxmcs;
  uint32_t maxmcs;
  size_t n_sorting;
  Protocol__FlexDlSorting *sorting;
  protobuf_c_boolean has_accounting;
  Protocol__FlexDlAccountingPolicy accounting;
  char *scheduler_name;
};
#define PROTOCOL__FLEX_DL_SLICE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&protocol__flex_dl_slice__descriptor) \
    , 0, 0, 0, PROTOCOL__FLEX_SLICE_LABEL__xMBB, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,NULL, 0, PROTOCOL__FLEX_DL_ACCOUNTING_POLICY__POL_FAIR, NULL }


struct  _Protocol__FlexUlSlice
{
  ProtobufCMessage base;
  protobuf_c_boolean has_id;
  uint32_t id;
  protobuf_c_boolean has_label;
  Protocol__FlexSliceLabel label;
  /*
   * should be between 0 and 100
   */
  protobuf_c_boolean has_percentage;
  uint32_t percentage;
  /*
   * whether this slice should be exempted form interslice sharing
   */
  protobuf_c_boolean has_isolation;
  protobuf_c_boolean isolation;
  /*
   * increasing value means increasing prio
   */
  protobuf_c_boolean has_priority;
  uint32_t priority;
  /*
   * RB start to use (in frequency) in the range [0, N_RB_MAX]
   */
  protobuf_c_boolean has_first_rb;
  uint32_t first_rb;
  /*
   * TODO RB number
   *optional uint32 length_rb = 7;
   * maximum MCS to be allowed in this slice
   */
  protobuf_c_boolean has_maxmcs;
  uint32_t maxmcs;
  size_t n_sorting;
  Protocol__FlexUlSorting *sorting;
  protobuf_c_boolean has_accounting;
  Protocol__FlexUlAccountingPolicy accounting;
  char *scheduler_name;
};
#define PROTOCOL__FLEX_UL_SLICE__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&protocol__flex_ul_slice__descriptor) \
    , 0, 0, 0, PROTOCOL__FLEX_SLICE_LABEL__xMBB, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,NULL, 0, PROTOCOL__FLEX_UL_ACCOUNTING_POLICY__POLU_FAIR, NULL }


struct  _Protocol__FlexDrxConfig
{
  ProtobufCMessage base;
  /*
   * Timer in SF. See TS 36.321
   */
  protobuf_c_boolean has_on_duration_timer;
  uint32_t on_duration_timer;
  /*
   * Timer in SF. See TS 36.321
   */
  protobuf_c_boolean has_drx_inactivity_timer;
  uint32_t drx_inactivity_timer;
  /*
   * Timer in SF. See TS 36.321
   */
  protobuf_c_boolean has_drx_retransmission_timer;
  uint32_t drx_retransmission_timer;
  /*
   * In SF. See TS 36.321
   */
  protobuf_c_boolean has_long_drx_cycle;
  uint32_t long_drx_cycle;
  /*
   * See TS 36.321
   */
  protobuf_c_boolean has_long_drx_cycle_start_offset;
  uint32_t long_drx_cycle_start_offset;
  /*
   * In SF
   */
  protobuf_c_boolean has_short_drx_cycle;
  uint32_t short_drx_cycle;
  /*
   * Timer in subframes. See TS 36.321
   */
  protobuf_c_boolean has_drx_short_cycle_timer;
  uint32_t drx_short_cycle_timer;
};
#define PROTOCOL__FLEX_DRX_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&protocol__flex_drx_config__descriptor) \
    , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }


struct  _Protocol__FlexSpsConfig
{
  ProtobufCMessage base;
  /*
   * SPS UL scheduling interval in SF
   */
  protobuf_c_boolean has_semi_persistent_sched_interval_ul;
  uint32_t semi_persistent_sched_interval_ul;
  /*
   * SPS DL scheduling interval in SF
   */
  protobuf_c_boolean has_semi_persistent_sched_interval_dl;
  uint32_t semi_persistent_sched_interval_dl;
  /*
   * Number of SPS HARQ processes. See TS 36.321
   */
  protobuf_c_boolean has_num_of_conf_sps_proc;
  uint32_t num_of_conf_sps_proc;
  /*
   * See TS36.213. Ignored when config is used
   */
  size_t n_n1_pucch_an_persistent_element;
  uint32_t *n1_pucch_an_persistent_element;
  /*
   * as part of FLPT_SET_UE_CONFIG
   */
  /*
   * number of empty transmissions before release of SPS
   */
  protobuf_c_boolean has_implicit_release_after;
  uint32_t implicit_release_after;
};
#define PROTOCOL__FLEX_SPS_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&protocol__flex_sps_config__descriptor) \
    , 0, 0, 0, 0, 0, 0, 0,NULL, 0, 0 }


struct  _Protocol__FlexSrConfig
{
  ProtobufCMessage base;
  /*
   * Indicates if SR config should be changed or released
   */
  protobuf_c_boolean has_sr_action;
  uint32_t sr_action;
  /*
   * One of the FLSRA_* enum values
   */
  /*
   * SR scheduling interval in SF
   */
  protobuf_c_boolean has_sched_interval;
  uint32_t sched_interval;
  /*
   * See TS 36.213
   */
  protobuf_c_boolean has_dsr_trans_max;
  uint32_t dsr_trans_max;
};
#define PROTOCOL__FLEX_SR_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&protocol__flex_sr_config__descriptor) \
    , 0, 0, 0, 0, 0, 0 }


struct  _Protocol__FlexCqiConfig
{
  ProtobufCMessage base;
  /*
   * Indicats if CQI changed or released.
   */
  protobuf_c_boolean has_cqi_action;
  uint32_t cqi_action;
  /*
   * One of the FLSRA_* enum values
   */
  /*
   * CQI scheduling interval in SF
   */
  protobuf_c_boolean has_cqi_sched_interval;
  uint32_t cqi_sched_interval;
  /*
   * RI scheduling interval in SF
   */
  protobuf_c_boolean has_ri_sched_interval;
  uint32_t ri_sched_interval;
};
#define PROTOCOL__FLEX_CQI_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&protocol__flex_cqi_config__descriptor) \
    , 0, 0, 0, 0, 0, 0 }


struct  _Protocol__FlexUeCapabilities
{
  ProtobufCMessage base;
  /*
   * Boolean value. Only half duplex support. FDD operation
   */
  protobuf_c_boolean has_half_duplex;
  uint32_t half_duplex;
  /*
   * Support for intra-subframe hopping. Boolean value
   */
  protobuf_c_boolean has_intra_sf_hopping;
  uint32_t intra_sf_hopping;
  /*
   * Support for type 2 hopping with n_sb > 1
   */
  protobuf_c_boolean has_type2_sb_1;
  uint32_t type2_sb_1;
  protobuf_c_boolean has_ue_category;
  uint32_t ue_category;
  /*
   * Boolean value. UE support for resource allocation type 1
   */
  protobuf_c_boolean has_res_alloc_type1;
  uint32_t res_alloc_type1;
};
#define PROTOCOL__FLEX_UE_CAPABILITIES__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&protocol__flex_ue_capabilities__descriptor) \
    , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }


struct  _Protocol__FlexScellConfig
{
  ProtobufCMessage base;
  /*
   * Id of the carrier component
   */
  protobuf_c_boolean has_carrier_index;
  uint32_t carrier_index;
  /*
   * Index of this Scell (RRC SCellIndex)
   */
  protobuf_c_boolean has_scell_index;
  uint32_t scell_index;
  /*
   * Boolean value. Indicates if cross-carrier scheduling
   */
  protobuf_c_boolean has_use_ccs;
  uint32_t use_ccs;
  /*
   * is used by this SCell
   */
  /*
   * Index of the cell responsible for scheduling
   */
  protobuf_c_boolean has_sched_cell_index;
  uint32_t sched_cell_index;
  /*
   * this SCell if cross-carrier scheduling is enabled
   */
  /*
   * Starting OFDM symbol of PDSCH data region for this SCell
   */
  protobuf_c_boolean has_pdsch_start;
  uint32_t pdsch_start;
};
#define PROTOCOL__FLEX_SCELL_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&protocol__flex_scell_config__descriptor) \
    , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }


struct  _Protocol__FlexLcConfig
{
  ProtobufCMessage base;
  /*
   * The logical channel id
   */
  protobuf_c_boolean has_lcid;
  uint32_t lcid;
  /*
   * The logical channel group (0..3) the LC is mapped to
   */
  protobuf_c_boolean has_lcg;
  uint32_t lcg;
  /*
   * The LC direction. One of the FLLCD_* enum values
   */
  protobuf_c_boolean has_direction;
  uint32_t direction;
  /*
   * GBR or NGBR bearer. One of the FLQBT_* enum values
   */
  protobuf_c_boolean has_qos_bearer_type;
  uint32_t qos_bearer_type;
  /*
   * The QCI defined in TS 23.203, coded as defined in TS 36.413
   */
  protobuf_c_boolean has_qci;
  uint32_t qci;
  /*
   * One less than the actual QCI value
   */
  /*
   * In bps (GBR only)
   */
  protobuf_c_boolean has_e_rab_max_bitrate_ul;
  uint64_t e_rab_max_bitrate_ul;
  /*
   * In bps (GBR only)
   */
  protobuf_c_boolean has_e_rab_max_bitrate_dl;
  uint64_t e_rab_max_bitrate_dl;
  /*
   * In bps (GBR only)
   */
  protobuf_c_boolean has_e_rab_guaranteed_bitrate_ul;
  uint64_t e_rab_guaranteed_bitrate_ul;
  /*
   * In bps (GBR only)
   */
  protobuf_c_boolean has_e_rab_guaranteed_bitrate_dl;
  uint64_t e_rab_guaranteed_bitrate_dl;
};
#define PROTOCOL__FLEX_LC_CONFIG__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&protocol__flex_lc_config__descriptor) \
    , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }


struct  _Protocol__FlexPlmn
{
  ProtobufCMessage base;
  protobuf_c_boolean has_mcc;
  uint32_t mcc;
  protobuf_c_boolean has_mnc;
  uint32_t mnc;
  protobuf_c_boolean has_mnc_length;
  uint32_t mnc_length;
};
#define PROTOCOL__FLEX_PLMN__INIT \
 { PROTOBUF_C_MESSAGE_INIT (&protocol__flex_plmn__descriptor) \
    , 0, 0, 0, 0, 0, 0 }


/* Protocol__FlexSiConfig methods */
void   protocol__flex_si_config__init
                     (Protocol__FlexSiConfig         *message);
size_t protocol__flex_si_config__get_packed_size
                     (const Protocol__FlexSiConfig   *message);
size_t protocol__flex_si_config__pack
                     (const Protocol__FlexSiConfig   *message,
                      uint8_t             *out);
size_t protocol__flex_si_config__pack_to_buffer
                     (const Protocol__FlexSiConfig   *message,
                      ProtobufCBuffer     *buffer);
Protocol__FlexSiConfig *
       protocol__flex_si_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   protocol__flex_si_config__free_unpacked
                     (Protocol__FlexSiConfig *message,
                      ProtobufCAllocator *allocator);
/* Protocol__FlexSiMessage methods */
void   protocol__flex_si_message__init
                     (Protocol__FlexSiMessage         *message);
size_t protocol__flex_si_message__get_packed_size
                     (const Protocol__FlexSiMessage   *message);
size_t protocol__flex_si_message__pack
                     (const Protocol__FlexSiMessage   *message,
                      uint8_t             *out);
size_t protocol__flex_si_message__pack_to_buffer
                     (const Protocol__FlexSiMessage   *message,
                      ProtobufCBuffer     *buffer);
Protocol__FlexSiMessage *
       protocol__flex_si_message__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   protocol__flex_si_message__free_unpacked
                     (Protocol__FlexSiMessage *message,
                      ProtobufCAllocator *allocator);
/* Protocol__FlexDlSlice methods */
void   protocol__flex_dl_slice__init
                     (Protocol__FlexDlSlice         *message);
size_t protocol__flex_dl_slice__get_packed_size
                     (const Protocol__FlexDlSlice   *message);
size_t protocol__flex_dl_slice__pack
                     (const Protocol__FlexDlSlice   *message,
                      uint8_t             *out);
size_t protocol__flex_dl_slice__pack_to_buffer
                     (const Protocol__FlexDlSlice   *message,
                      ProtobufCBuffer     *buffer);
Protocol__FlexDlSlice *
       protocol__flex_dl_slice__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   protocol__flex_dl_slice__free_unpacked
                     (Protocol__FlexDlSlice *message,
                      ProtobufCAllocator *allocator);
/* Protocol__FlexUlSlice methods */
void   protocol__flex_ul_slice__init
                     (Protocol__FlexUlSlice         *message);
size_t protocol__flex_ul_slice__get_packed_size
                     (const Protocol__FlexUlSlice   *message);
size_t protocol__flex_ul_slice__pack
                     (const Protocol__FlexUlSlice   *message,
                      uint8_t             *out);
size_t protocol__flex_ul_slice__pack_to_buffer
                     (const Protocol__FlexUlSlice   *message,
                      ProtobufCBuffer     *buffer);
Protocol__FlexUlSlice *
       protocol__flex_ul_slice__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   protocol__flex_ul_slice__free_unpacked
                     (Protocol__FlexUlSlice *message,
                      ProtobufCAllocator *allocator);
/* Protocol__FlexDrxConfig methods */
void   protocol__flex_drx_config__init
                     (Protocol__FlexDrxConfig         *message);
size_t protocol__flex_drx_config__get_packed_size
                     (const Protocol__FlexDrxConfig   *message);
size_t protocol__flex_drx_config__pack
                     (const Protocol__FlexDrxConfig   *message,
                      uint8_t             *out);
size_t protocol__flex_drx_config__pack_to_buffer
                     (const Protocol__FlexDrxConfig   *message,
                      ProtobufCBuffer     *buffer);
Protocol__FlexDrxConfig *
       protocol__flex_drx_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   protocol__flex_drx_config__free_unpacked
                     (Protocol__FlexDrxConfig *message,
                      ProtobufCAllocator *allocator);
/* Protocol__FlexSpsConfig methods */
void   protocol__flex_sps_config__init
                     (Protocol__FlexSpsConfig         *message);
size_t protocol__flex_sps_config__get_packed_size
                     (const Protocol__FlexSpsConfig   *message);
size_t protocol__flex_sps_config__pack
                     (const Protocol__FlexSpsConfig   *message,
                      uint8_t             *out);
size_t protocol__flex_sps_config__pack_to_buffer
                     (const Protocol__FlexSpsConfig   *message,
                      ProtobufCBuffer     *buffer);
Protocol__FlexSpsConfig *
       protocol__flex_sps_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   protocol__flex_sps_config__free_unpacked
                     (Protocol__FlexSpsConfig *message,
                      ProtobufCAllocator *allocator);
/* Protocol__FlexSrConfig methods */
void   protocol__flex_sr_config__init
                     (Protocol__FlexSrConfig         *message);
size_t protocol__flex_sr_config__get_packed_size
                     (const Protocol__FlexSrConfig   *message);
size_t protocol__flex_sr_config__pack
                     (const Protocol__FlexSrConfig   *message,
                      uint8_t             *out);
size_t protocol__flex_sr_config__pack_to_buffer
                     (const Protocol__FlexSrConfig   *message,
                      ProtobufCBuffer     *buffer);
Protocol__FlexSrConfig *
       protocol__flex_sr_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   protocol__flex_sr_config__free_unpacked
                     (Protocol__FlexSrConfig *message,
                      ProtobufCAllocator *allocator);
/* Protocol__FlexCqiConfig methods */
void   protocol__flex_cqi_config__init
                     (Protocol__FlexCqiConfig         *message);
size_t protocol__flex_cqi_config__get_packed_size
                     (const Protocol__FlexCqiConfig   *message);
size_t protocol__flex_cqi_config__pack
                     (const Protocol__FlexCqiConfig   *message,
                      uint8_t             *out);
size_t protocol__flex_cqi_config__pack_to_buffer
                     (const Protocol__FlexCqiConfig   *message,
                      ProtobufCBuffer     *buffer);
Protocol__FlexCqiConfig *
       protocol__flex_cqi_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   protocol__flex_cqi_config__free_unpacked
                     (Protocol__FlexCqiConfig *message,
                      ProtobufCAllocator *allocator);
/* Protocol__FlexUeCapabilities methods */
void   protocol__flex_ue_capabilities__init
                     (Protocol__FlexUeCapabilities         *message);
size_t protocol__flex_ue_capabilities__get_packed_size
                     (const Protocol__FlexUeCapabilities   *message);
size_t protocol__flex_ue_capabilities__pack
                     (const Protocol__FlexUeCapabilities   *message,
                      uint8_t             *out);
size_t protocol__flex_ue_capabilities__pack_to_buffer
                     (const Protocol__FlexUeCapabilities   *message,
                      ProtobufCBuffer     *buffer);
Protocol__FlexUeCapabilities *
       protocol__flex_ue_capabilities__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   protocol__flex_ue_capabilities__free_unpacked
                     (Protocol__FlexUeCapabilities *message,
                      ProtobufCAllocator *allocator);
/* Protocol__FlexScellConfig methods */
void   protocol__flex_scell_config__init
                     (Protocol__FlexScellConfig         *message);
size_t protocol__flex_scell_config__get_packed_size
                     (const Protocol__FlexScellConfig   *message);
size_t protocol__flex_scell_config__pack
                     (const Protocol__FlexScellConfig   *message,
                      uint8_t             *out);
size_t protocol__flex_scell_config__pack_to_buffer
                     (const Protocol__FlexScellConfig   *message,
                      ProtobufCBuffer     *buffer);
Protocol__FlexScellConfig *
       protocol__flex_scell_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   protocol__flex_scell_config__free_unpacked
                     (Protocol__FlexScellConfig *message,
                      ProtobufCAllocator *allocator);
/* Protocol__FlexLcConfig methods */
void   protocol__flex_lc_config__init
                     (Protocol__FlexLcConfig         *message);
size_t protocol__flex_lc_config__get_packed_size
                     (const Protocol__FlexLcConfig   *message);
size_t protocol__flex_lc_config__pack
                     (const Protocol__FlexLcConfig   *message,
                      uint8_t             *out);
size_t protocol__flex_lc_config__pack_to_buffer
                     (const Protocol__FlexLcConfig   *message,
                      ProtobufCBuffer     *buffer);
Protocol__FlexLcConfig *
       protocol__flex_lc_config__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   protocol__flex_lc_config__free_unpacked
                     (Protocol__FlexLcConfig *message,
                      ProtobufCAllocator *allocator);
/* Protocol__FlexPlmn methods */
void   protocol__flex_plmn__init
                     (Protocol__FlexPlmn         *message);
size_t protocol__flex_plmn__get_packed_size
                     (const Protocol__FlexPlmn   *message);
size_t protocol__flex_plmn__pack
                     (const Protocol__FlexPlmn   *message,
                      uint8_t             *out);
size_t protocol__flex_plmn__pack_to_buffer
                     (const Protocol__FlexPlmn   *message,
                      ProtobufCBuffer     *buffer);
Protocol__FlexPlmn *
       protocol__flex_plmn__unpack
                     (ProtobufCAllocator  *allocator,
                      size_t               len,
                      const uint8_t       *data);
void   protocol__flex_plmn__free_unpacked
                     (Protocol__FlexPlmn *message,
                      ProtobufCAllocator *allocator);
/* --- per-message closures --- */

typedef void (*Protocol__FlexSiConfig_Closure)
                 (const Protocol__FlexSiConfig *message,
                  void *closure_data);
typedef void (*Protocol__FlexSiMessage_Closure)
                 (const Protocol__FlexSiMessage *message,
                  void *closure_data);
typedef void (*Protocol__FlexDlSlice_Closure)
                 (const Protocol__FlexDlSlice *message,
                  void *closure_data);
typedef void (*Protocol__FlexUlSlice_Closure)
                 (const Protocol__FlexUlSlice *message,
                  void *closure_data);
typedef void (*Protocol__FlexDrxConfig_Closure)
                 (const Protocol__FlexDrxConfig *message,
                  void *closure_data);
typedef void (*Protocol__FlexSpsConfig_Closure)
                 (const Protocol__FlexSpsConfig *message,
                  void *closure_data);
typedef void (*Protocol__FlexSrConfig_Closure)
                 (const Protocol__FlexSrConfig *message,
                  void *closure_data);
typedef void (*Protocol__FlexCqiConfig_Closure)
                 (const Protocol__FlexCqiConfig *message,
                  void *closure_data);
typedef void (*Protocol__FlexUeCapabilities_Closure)
                 (const Protocol__FlexUeCapabilities *message,
                  void *closure_data);
typedef void (*Protocol__FlexScellConfig_Closure)
                 (const Protocol__FlexScellConfig *message,
                  void *closure_data);
typedef void (*Protocol__FlexLcConfig_Closure)
                 (const Protocol__FlexLcConfig *message,
                  void *closure_data);
typedef void (*Protocol__FlexPlmn_Closure)
                 (const Protocol__FlexPlmn *message,
                  void *closure_data);

/* --- services --- */


/* --- descriptors --- */

extern const ProtobufCEnumDescriptor    protocol__flex_hopping_mode__descriptor;
extern const ProtobufCEnumDescriptor    protocol__flex_phich_resource__descriptor;
extern const ProtobufCEnumDescriptor    protocol__flex_phich_duration__descriptor;
extern const ProtobufCEnumDescriptor    protocol__flex_ul_cyclic_prefix_length__descriptor;
extern const ProtobufCEnumDescriptor    protocol__flex_dl_cyclic_prefix_length__descriptor;
extern const ProtobufCEnumDescriptor    protocol__flex_duplex_mode__descriptor;
extern const ProtobufCEnumDescriptor    protocol__flex_qam__descriptor;
extern const ProtobufCEnumDescriptor    protocol__flex_dl_sorting__descriptor;
extern const ProtobufCEnumDescriptor    protocol__flex_ul_sorting__descriptor;
extern const ProtobufCEnumDescriptor    protocol__flex_dl_accounting_policy__descriptor;
extern const ProtobufCEnumDescriptor    protocol__flex_ul_accounting_policy__descriptor;
extern const ProtobufCEnumDescriptor    protocol__flex_slice_label__descriptor;
extern const ProtobufCEnumDescriptor    protocol__flex_meas_gap_config_pattern__descriptor;
extern const ProtobufCEnumDescriptor    protocol__flex_setup_release_action__descriptor;
extern const ProtobufCEnumDescriptor    protocol__flex_ue_transmission_antenna__descriptor;
extern const ProtobufCEnumDescriptor    protocol__flex_aperiodic_cqi_report_mode__descriptor;
extern const ProtobufCEnumDescriptor    protocol__flex_tdd_ack_nack_feedback_mode__descriptor;
extern const ProtobufCEnumDescriptor    protocol__flex_lc_direction__descriptor;
extern const ProtobufCEnumDescriptor    protocol__flex_qos_bearer_type__descriptor;
extern const ProtobufCEnumDescriptor    protocol__flex_ue_state_change_type__descriptor;
extern const ProtobufCMessageDescriptor protocol__flex_si_config__descriptor;
extern const ProtobufCMessageDescriptor protocol__flex_si_message__descriptor;
extern const ProtobufCMessageDescriptor protocol__flex_dl_slice__descriptor;
extern const ProtobufCMessageDescriptor protocol__flex_ul_slice__descriptor;
extern const ProtobufCMessageDescriptor protocol__flex_drx_config__descriptor;
extern const ProtobufCMessageDescriptor protocol__flex_sps_config__descriptor;
extern const ProtobufCMessageDescriptor protocol__flex_sr_config__descriptor;
extern const ProtobufCMessageDescriptor protocol__flex_cqi_config__descriptor;
extern const ProtobufCMessageDescriptor protocol__flex_ue_capabilities__descriptor;
extern const ProtobufCMessageDescriptor protocol__flex_scell_config__descriptor;
extern const ProtobufCMessageDescriptor protocol__flex_lc_config__descriptor;
extern const ProtobufCMessageDescriptor protocol__flex_plmn__descriptor;

PROTOBUF_C__END_DECLS


#endif  /* PROTOBUF_C_config_5fcommon_2eproto__INCLUDED */
